<!-- Intro.js CSS (선택) -->
<link
  rel="stylesheet"
  href="https://unpkg.com/intro.js/minified/introjs.min.css"
/>

<!-- coach_map_user.html : Spotlight + Curved Arrows + Tips (event-driven, no RAF loop) -->
<style>
  .coach-overlay { position: fixed; inset: 0; z-index: 2147483000; pointer-events: none; }
  .coach-layer   { position: absolute; inset: 0; }
  /* dim(어둡게) 레이어: 마스크로 구멍 뚫림 */
  .coach-dim     { width:100%; height:100%; display:block; z-index:2147483001; }

  /* 화살표는 dim 위, 말풍선 아래(말풍선과 겹치지 않게) */
  .coach-arrows  { position:absolute; inset:0; z-index:2147483002; pointer-events:none; }

  /* 말풍선/푸터는 최상단 클릭 가능 */
  .coach-tip {
    position: absolute; max-width: 320px;
    background: #1a1a1a; color: #fff; border: 1px solid #2a2a2a;
    border-radius: 10px; padding: 12px 14px; box-shadow: 0 12px 28px rgba(0,0,0,.35);
    font-size: 13px; line-height: 1.5; z-index: 2147483004; pointer-events: auto;
  }
  .coach-tip strong { font-size: 13.5px; }
  .coach-footer {
    position: absolute; left:0; right:0; top:0px;
    background: rgba(17,17,17,.95); color:#eee; border-top:1px solid rgba(255,255,255,.12);
    padding: 10px 16px; display:flex; align-items:center; gap:10px;
    z-index: 2147483004; pointer-events: auto; font-size: 13px;
  }
  .coach-footer button{
    margin-left:auto; background:transparent; border:1px solid rgba(255,255,255,.2);
    color:#fff; padding:6px 10px; border-radius:8px; cursor:pointer;
  }
</style>

<div id="coachOverlay" class="coach-overlay" style="display:block">
  <!-- 어두운 배경 + 스포트라이트 구멍 -->
  <svg id="coachDim" class="coach-layer coach-dim" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none">
    <defs>
      <mask id="coachMask">
        <rect x="0" y="0" width="100%" height="100%" fill="white"/>
        <!-- JS가 검정 rect(구멍)을 추가 -->
      </mask>
    </defs>
    <rect x="0" y="0" width="100%" height="100%" fill="rgba(0,0,0,.62)" mask="url(#coachMask)"/>
  </svg>

  <!-- 곡선 화살표 레이어 (marker는 이 SVG 안에 둬야 적용됨) -->
  <svg id="coachArrows" class="coach-layer coach-arrows" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <!-- 화살표 머리는 검정색 -->
      <marker id="coachArrowHead" markerWidth="12" markerHeight="12" refX="7" refY="6" orient="auto">
        <path d="M0,0 L0,12 L11,6 z" fill="black"/>
      </marker>
    </defs>
  </svg>

  <!-- 말풍선들: 위치는 top/left/right/bottom으로 조정, data-target은 연결 대상 -->
  <div class="coach-tip" data-target="#start" style="top:120px; left:450px;">
    <strong>출발지 / 도착지</strong><br>
    출발지 도착지 입력<br>
    은평구, 마포구, 서대문구 주소만 입력 가능
  </div>

  <div class="coach-tip" data-target=".obstacle-section" style="top:230px; left:450px;">
    <strong>방해요소</strong><br>
    원하는 방해요소와 숫자입력 후 지도 클릭으로 수동 추가 가능<br>
    방해요소가 2개 이상이어도 마커는 1개만 배치<br>
    <b>도로/다리 붕괴</b>는 도로 위에서만 추가 가능
  </div>

  <div class="coach-tip" data-target="#addManualObstacleBtn" style="top:410px; left:450px;">
    <strong>위도 / 경도 입력</strong><br>
    방해요소 선택 후 위도, 경도를 직접 입력하고 <br><b>추가</b> 버튼을 누르면 선택한 방해요소가 해당 좌표에 배치
  </div>

  <div class="coach-tip"
      data-key="routeGuide"
      data-target="#routeBtn"
      style="top: 550px; left: 450px; width: 260px;">
    <strong>길찾기</strong><br>
    <b>D* Lite / CCH + A* / RTAA*</b> 알고리즘별 경로, 이동거리, 예상시간 확인 가능 
  </div>

  <div class="coach-tip"
      data-key="favorites"
      data-target="#showFavoritesBtn"
      style="top: 680px; left: 450px; width: 260px;">
    <strong>즐겨찾기</strong><br>
    길찾기 클릭 후 <b>즐겨찾기 추가</b>를 하면 경로가 저장되고, 즐겨찾기 버튼으로 목록 확인 가능
  </div>

  <div class="coach-tip"
      id="tipReset"
      data-key="reset"
      data-target="#resetBtn"
      style="bottom:280px; left:40px;">
    <strong>다시 입력</strong><br>
    출발지/도착지, 알고리즘별 경로, 방해요소 초기화
  </div>

  <div class="coach-tip" data-target=".map-style-switcher" style="top:105px; right:350px;">
    <strong>지도 스타일</strong><br>
    일반/위성/지형 중 지도 스타일 변경 가능 
    <br><br>
    <strong>특수 장애물</strong><br>
    철조망/낙석 버튼으로 <br>지정된 방해요소 위치 획인 가능
  </div>

  <div class="coach-tip"
      id="tipCompare"
      data-key="compare"
      data-target="#legendBox"
      style="bottom:130px; right:200px;">
    <strong>경로 비교</strong><br>
    각 알고리즘의 결과를 색상과 함께 비교
  </div>

  <div class="coach-footer">
    <button id="coachCloseBtn" type="button">닫기 ✕</button>
  </div>
</div>

<script>
(function(){
  const overlay   = document.getElementById('coachOverlay');
  const dimSvg    = document.getElementById('coachDim');
  const mask      = dimSvg.querySelector('#coachMask');
  const arrowsSvg = document.getElementById('coachArrows');

  // 스포트라이트 대상(필요시 추가/삭제)
  const HOLES = [
    { sel:'#start', pad:8, r:8 },
    { sel:'#end', pad:8, r:8 },
    { sel:'.obstacle-section', pad:10, r:12 },
    { sel:'#addManualObstacleBtn', pad:8, r:8 },
    { sel:'#manualLatInput', pad:8, r:8 },
    { sel:'#manualLngInput', pad:8, r:8 },
    { sel:'#resetBtn', pad:10, r:10 },
    { sel:'#routeBtn', pad:10, r:8 },
    { sel:'#showFavoritesBtn', pad:10, r:10 },
    { sel:'.map-style-switcher', pad:8, r:8 },
    { sel:'#specialObstacleButtons', pad:8, r:8 },
    /* 범례 패딩 확대(그림자/외곽 포함) */
    { sel:'#legendBox', pad:16, r:8 }
  ];

  function rebuild(){
    // 1) SVG viewport를 현재 창 크기에 맞춤
    const w = window.innerWidth;
    const h = window.innerHeight;

    // dim SVG
    dimSvg.setAttribute('width',  w);
    dimSvg.setAttribute('height', h);
    dimSvg.setAttribute('viewBox', `0 0 ${w} ${h}`);

    // arrows SVG
    arrowsSvg.setAttribute('width',  w);
    arrowsSvg.setAttribute('height', h);
    arrowsSvg.setAttribute('viewBox', `0 0 ${w} ${h}`);

    // 마스크 구멍 초기화(첫 흰 rect 유지)
    [...mask.querySelectorAll('rect[data-hole]')].forEach(n=>n.remove());

    // 화살표 초기화(마커 defs 보존)
    const defs = arrowsSvg.querySelector('defs');
    arrowsSvg.innerHTML = '';
    if (defs) arrowsSvg.appendChild(defs);

    // 2) 구멍 생성
    const holeRects = {};
    HOLES.forEach(hole=>{
      const els = document.querySelectorAll(hole.sel);
      if (!els.length) return;

      els.forEach((el, i)=>{
        const b = el.getBoundingClientRect();   // viewport 좌표
        if (b.width === 0 && b.height === 0) return;
        const pad = hole.pad || 0;
        const x = Math.round(b.left - pad);
        const y = Math.round(b.top  - pad);
        const rw = Math.round(b.width  + pad*2);
        const rh = Math.round(b.height + pad*2);

        // 구멍(rect)
        const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
        r.setAttribute('x', x); r.setAttribute('y', y);
        r.setAttribute('width',  rw); r.setAttribute('height', rh);
        r.setAttribute('rx', hole.r || 6); r.setAttribute('ry', hole.r || 6);
        r.setAttribute('fill', 'black');
        r.setAttribute('data-hole', '1');
        mask.appendChild(r);

        const key = i===0 ? hole.sel : `${hole.sel}[${i}]`;
        holeRects[key] = { x, y, w: rw, h: rh };
      });
    });

    // 3) 말풍선 중심 → 대상 사각형 가장 가까운 변으로 '곡선' 화살표
    document.querySelectorAll('.coach-tip').forEach(tip=>{
      const tb = tip.getBoundingClientRect();
      const tipCenter = { x: tb.left + tb.width/2, y: tb.top + tb.height/2 };

      const sels = (tip.dataset.target||'').split(',').map(s=>s.trim()).filter(Boolean);
      let rect;
      for (const sel of sels){
        rect = holeRects[sel] ?? holeRects[`${sel}[0]`];
        if (rect) break;
      }
      if (!rect) return;

      // 가장 가까운 변으로 스냅
      const cxRect = rect.x + rect.w/2, cyRect = rect.y + rect.h/2;
      const dx = tipCenter.x - cxRect, dy = tipCenter.y - cyRect;
      const ax = Math.abs(dx), ay = Math.abs(dy);
      let ex, ey;
      if (ax/rect.w > ay/rect.h) { // 좌우 변
        ex = (dx>0) ? rect.x + rect.w : rect.x;
        ey = cyRect + dy * (rect.w/2) / Math.max(ax,1);
      } else { // 상하 변
        ex = cxRect + dx * (rect.h/2) / Math.max(ay,1);
        ey = (dy>0) ? rect.y + rect.h : rect.y;
      }

      // 베지어 제어점
      const cpx = (tipCenter.x + ex)/2 + (tipCenter.x < ex ? -40 : 40);
      const cpy = (tipCenter.y + ey)/2 + (tipCenter.y < ey ? -20 : 20);
      const d = `M ${tipCenter.x},${tipCenter.y} Q ${cpx},${cpy} ${ex},${ey}`;

      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', d);
      p.setAttribute('fill', 'none');
      p.setAttribute('stroke', 'black');
      p.setAttribute('stroke-width', 2.5);
      p.setAttribute('marker-end','url(#coachArrowHead)');
      arrowsSvg.appendChild(p);
    });
  }

  // 디바운스(성능)
  let t; 
  const safeRebuild = ()=>{ clearTimeout(t); t=setTimeout(rebuild, 120); };

  // 초기 표시: DOMContentLoaded 이후에 실행(초기 2회 보정, 지연 확대)
  document.addEventListener('DOMContentLoaded', () => {
    requestAnimationFrame(() => { 
      rebuild(); 
      setTimeout(rebuild, 300); // 150ms → 300ms로 확대
    });
  }, { once:true });

  // 반응형 업데이트 (스크롤 리스너는 제거)
  window.addEventListener('resize', safeRebuild, { passive:true });
  // window.addEventListener('scroll', safeRebuild, { passive:true }); // 불필요 → 제거

  // 닫기
  document.getElementById('coachCloseBtn').addEventListener('click', ()=>{
    overlay.style.display='none';
  });

  // 안전장치: 만약 head에 렌더되면 body로 이동
  if (overlay.parentNode && overlay.parentNode.tagName === 'HEAD') {
    document.addEventListener('DOMContentLoaded', ()=> document.body.appendChild(overlay), { once:true });
  }

  /* ----------------------------
     추가 안정화: legendBox 등장 감지
     ---------------------------- */

  // legendBox가 이미 있으면 즉시, 없으면 '한 번만' 감시
  function armCoachRebuildOnce() {
    if (document.getElementById('legendBox')) {
      safeRebuild();
      return;
    }
    const mo = new MutationObserver((muts, obs) => {
      if (document.getElementById('legendBox')) {
        safeRebuild();
        obs.disconnect(); // 한 번만 실행
      }
    });
    mo.observe(document.body, { childList: true, subtree: true });
  }

  // DOM 준비되면 감시 장착(한 번만)
  window.addEventListener('DOMContentLoaded', armCoachRebuildOnce, { once: true });

  // 모든 리소스 로드 후에도 약간 지연하여 보정
  window.addEventListener('load', () => {
    setTimeout(safeRebuild, 250);
  }, { once: true });

})();
</script>
